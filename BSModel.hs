{-# LANGUAGE 
  TypeSynonymInstances,
  MultiParamTypeClasses,
  FlexibleContexts #-}

-- Bitstring decision tree language model

module Main where

import System.IO.Unsafe (unsafePerformIO)

import Data.Array (Array(..), (!), listArray, bounds, assocs)
import Data.Ix (inRange, range)
import qualified Data.Map as M (lookup, toList)
import Data.List (zip3, zip4)
import Data.Maybe (fromJust)

import Stats
import DTree
import Util

-- Admissible questions are of the form (<predictor id>, <bitstring index>)
type Q = (Int, Int)

-- Predictors are formed by building bitstring arrays from prior n-grams
type Pred = Array Q Dir

-- And we arbitrarily define the L direction to be our "true"
-- direction (though this matches the `Data.List.partition` convention
-- too and so nothing will flip in the tree).
instance Splitter Pred Q where
    sfilter idx pred = if inRange (bounds pred) idx then pred ! idx == L else True

-- For the bitstring model, new questions are generated by querying
-- the bitstrings of each predictor in the maximally informative
-- order. Our seed is just an infinite list of acceptable questions
-- and proposing splitters is just taking the heads of the lists.
type Seed = [[Q]]

defaultSeed :: Int -> Seed
defaultSeed n = map (\i -> zip (repeat i) [0..]) [0..(n-1)]

-- Updating the seed just involves chopping the head off of whatever
-- index was chosen. Since they're already indexed by the `i` index in
-- the question itself, this is easy.
updateSeed seed (i, j) = let (front, key:back) = splitAt (i-1) seed
                         in front ++ (tail key):back

-- And now we've got enough to parametrize the whole tree!
growBSModel :: [(Char, Pred)] -> DTree (Int, Int) Double
growBSModel obs = growTree
                  obs 0.5
                  (map head) 
                  updateSeed 
                  (defaultSeed 3)
                  (entropy . freqFrom)
                  (entropy . freqFrom)
                  (\old new -> old - new > 0.005)
--
-- Main things

-- We use a default bitstring tree, generated from the agglomerative
-- code
tree1 :: BTree Char
tree1 = read "(((((a o) (i u)) e)  ) ((((((((v z) k) m) f) (((j q) b) p)) ((c w) t)) h) ((((r x) l) n) ((s y) (d g)))))"

-- We'll generate independent samples using 4-grams
makeObs :: DTree s Char -> String -> Maybe [(Char, Pred)]
makeObs tree str = mapM fn fourgrams
    where bs        = pathMap tree
          fourgrams = zip4 str (tail str) (drop 2 str) (drop 3 str)
          fn (a, b, c, d) = do aenc <- M.lookup a bs
                               benc <- M.lookup b bs
                               cenc <- M.lookup c bs
                               let n = length aenc
                                   full = listArray ((0, 0), (2, (n-1))) 
                                          (cenc ++ benc ++ aenc)
                               return $ (d, full)

train = unsafePerformIO (readFile "textA.txt")
traino = fromJust $ makeObs tree1 $ train
test = unsafePerformIO (readFile "textB.txt")
testo = fromJust $ makeObs tree1 $ test
tr = growBSModel traino
ftr = freqDTree tr traino

unStar :: Double -> Double
unStar a = a**2/(1-a**2)

main = do train <- readFile "textA.txt"
          test <- readFile "textB.txt"
          let (train_obs, held_obs) = splitAt 25000 $ fromJust $ makeObs tree1 train
              test_obs  = fromJust $ makeObs tree1 test
              tr = growBSModel train_obs
              ftr = freqDTree tr train_obs
              n = 2
              pars = range ((1, 1), (n-1, n-1))
              grid = listArray ((1,1), (n-1, n-1)) $ map (\(i, j) -> 
                             perplexity 
                             ftr 
                             (unStar $ (fromIntegral i)/(fromIntegral n), 
                              unStar $ (fromIntegral j)/(fromIntegral n))
                             held_obs)
                    pars
              betaparams = (1, 10000000)
          putStrLn $ "Test:  " ++ (show $ perplexity ftr betaparams test_obs)
          putStrLn $ "Train: " ++ (show $ perplexity ftr betaparams train_obs)
          writeFile "html/dtree.js" $ dTreeJSON tr showBSQ
          writeFile "html/lik.js" $ "var lik = [" ++
                        (concat $ map (++",") $
                             map show $ loglik ftr betaparams test_obs)
                        ++ "]"
          writeFile "html/grid.js" $ "var grid = [\n" ++
                        (concat $ map (\((i, j), v) -> 
                                           "{x: " ++ show i ++
                                           ", y: " ++ show j ++ 
                                           ", v: " ++ show v ++ 
                                           "},\n") $ assocs grid) 
                        ++ "]"
          writeFile "paths.csv" $ concat $ map 
                        (\((i, j), path, step) ->
                             show i ++ ", " ++ 
                             show j ++ ", " ++ 
                             show path ++ ", " ++ 
                             show step ++ "\n") $
                        zip3 (concat $ paths) ids steps
              where paths = map (qsteps tr []) $ map snd $ M.toList $ pathMap tr
                    ids   = concat $ zipWith ($) (map (\n -> replicate n) $ map length paths) [1..]
                    steps = concat $ map (\n -> [0..(n-1)]) $ map length paths
                    qsteps (Branch q l r) acc (L:path) = qsteps l (q:acc) path
                    qsteps (Branch q l r) acc (R:path) = qsteps r (q:acc) path
                    qsteps (Leaf _) acc path = reverse acc